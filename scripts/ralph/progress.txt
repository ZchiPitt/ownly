# Ralph Progress Log
# Project: Clekee - Smart Home Inventory App
# Branch: ralph/smart-home-inventory-mvp
# Created: 2026-01-23

## Codebase Patterns
- Uses Tailwind CSS v4 with @tailwindcss/vite plugin (no tailwind.config.js needed)
- Uses TanStack React Query for server state management
- Uses React Router v6 for navigation
- Mobile-first design approach
- Supabase client in `/src/lib/supabase.ts` - import { supabase } from '@/lib/supabase'
- Use `import.meta.env.VITE_*` for environment variables (Vite pattern)
- SQL migrations in `supabase/migrations/` with timestamp prefix (YYYYMMDDHHMMSS_description.sql)
- The `update_updated_at_column()` function exists and is reusable for other tables needing updated_at triggers
- Trigger chain for new users: auth.users -> profiles (via handle_new_user) -> user_settings (via handle_new_profile)
- The `update_location_item_count()` function maintains location.item_count on items table changes (handles insert, delete, soft-delete, restore, location changes)
- pgvector extension enabled for vector similarity search with HNSW indexing
- Use `search_similar_items()` function for client-side similarity search (uses auth.uid() for RLS)
- Types exported from `/src/types/index.ts` - import { Item, Profile, etc. } from '@/types'
- Database type from `/src/types/database.ts` - use with createClient<Database>()
- API request/response types from `/src/types/api.ts` for Edge Functions and client-side data fetching
- Storage bucket 'items' for photos: upload to items/{user_id}/{filename}, RLS enforces user-only access
- Path alias `@/` configured in vite.config.ts and tsconfig.app.json - use `import { x } from '@/lib/...'`
- AuthProvider context at `/src/contexts/AuthProvider.tsx` - wrap app with `<AuthProvider>`
- useAuth hook at `/src/hooks/useAuth.ts` - use `const { user, session, signIn, signOut } = useAuth()`
- For Fast Refresh compatibility: separate createContext() into its own .ts file, keep provider in .tsx
- ProtectedRoute wrapper at `/src/components/ProtectedRoute.tsx` - wrap protected routes with `<ProtectedRoute>`
- Context exports from `/src/contexts/index.ts` - import { AuthProvider, AuthContext } from '@/contexts'
- AppShell layout at `/src/components/layout/AppShell.tsx` - use `<AppShell>` for pages with bottom nav
- BottomNav at `/src/components/layout/BottomNav.tsx` - 4 tabs (Home, Add FAB, Inventory, Settings)
- Layout exports from `/src/components/layout/index.ts` - import { AppShell, BottomNav } from '@/components/layout'
- Pages exported from `/src/pages/index.ts` - import { SignupPage, LoginPage, etc. } from '@/pages'
- Auth pages (/signup, /login, /reset-password) are outside AppShell - no bottom navigation
- Simple Toast component at `/src/components/Toast.tsx` - use `<Toast message="" type="error" onClose={() => {}} />` (to be expanded in US-083)
- Image utilities at `/src/lib/imageUtils.ts` - use `validateImage()`, `compressImage()`, `convertHeicToJpeg()`, `generateThumbnail()`, `uploadToStorage()`, `processAndUploadImage()`
- Supabase Edge Functions in `supabase/functions/{function-name}/index.ts` - use Deno runtime with esm.sh imports
- Shared Edge Function utilities in `supabase/functions/_shared/` - e.g., cors.ts for CORS headers
- Edge Function auth validation: create Supabase client with user token, call auth.getUser() to verify
- ItemEditor component at `/src/components/ItemEditor.tsx` - use `<ItemEditor detectedItem={...} imageUrl={...} .../>` for item form
- ItemEditorPage at `/src/pages/ItemEditorPage.tsx` - route wrapper that receives state via React Router location.state
- Use `ReturnType<typeof setTimeout>` instead of `NodeJS.Timeout` for browser TypeScript compatibility
- useCategories hook at `/src/hooks/useCategories.ts` - use `const { categories, createCategory, getSortedCategories } = useCategories()`
- For Supabase Database types, include `Relationships: []` in table definitions for type compatibility

---

## 2026-01-23 - US-001
- What was implemented:
  - Created React app with Vite and TypeScript template
  - Installed and configured Tailwind CSS v4 with @tailwindcss/vite plugin
  - Installed React Router v6 for navigation
  - Installed TanStack React Query for server state management
  - Created base folder structure: /src/components, /src/pages, /src/hooks, /src/lib, /src/types
  - Configured App.tsx with QueryClientProvider and BrowserRouter

- Files changed:
  - package.json (dependencies and project metadata)
  - vite.config.ts (added Tailwind plugin)
  - src/index.css (Tailwind imports and base styles)
  - src/App.tsx (React Query and Router setup)
  - Created folder structure with .gitkeep files

- **Learnings for future iterations:**
  - Tailwind CSS v4 uses `@import "tailwindcss"` syntax, no @tailwind directives
  - Tailwind CSS v4 doesn't need tailwind.config.js when using @tailwindcss/vite plugin
  - The project uses React 19 with concurrent features
  - TanStack React Query v5 is installed
---

## 2026-01-23 - US-002
- What was implemented:
  - Installed @supabase/supabase-js package
  - Created /src/lib/supabase.ts with typed client initialization
  - Created placeholder Database type in /src/types/database.ts (to be expanded in US-011)
  - Created .env.example with VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY placeholders
  - Added .env to .gitignore for security

- Files changed:
  - package.json, package-lock.json (added supabase dependency)
  - .gitignore (added .env files)
  - .env.example (new - Supabase config template)
  - src/lib/supabase.ts (new - Supabase client)
  - src/types/database.ts (new - placeholder Database type)

- **Learnings for future iterations:**
  - Supabase client accepts a generic Database type for full TypeScript support
  - Use `import.meta.env.VITE_*` for Vite environment variables
  - Always validate env vars exist at runtime with meaningful error messages
  - The Database type will be expanded in US-011 with full schema
---

## 2026-01-23 - US-003
- What was implemented:
  - Created SQL migration file for profiles table at `supabase/migrations/20260123000001_create_profiles_table.sql`
  - Fields: id (uuid PK), user_id (uuid FK to auth.users, unique), display_name (varchar 50), avatar_url (text nullable), created_at, updated_at
  - Enabled RLS on profiles table
  - Added RLS policies: users can only read/update/insert their own profile
  - Added trigger `on_auth_user_created` to create profile on auth.users insert
  - Added `update_updated_at_column` function and trigger for automatic updated_at maintenance
  - Added documentation comments on table and columns

- Files changed:
  - supabase/migrations/20260123000001_create_profiles_table.sql (new)

- **Learnings for future iterations:**
  - Supabase migrations go in `supabase/migrations/` folder with timestamp prefix
  - Use `SECURITY DEFINER` on trigger functions that need to access auth.users
  - Extract display_name from email with `split_part(email, '@', 1)` as fallback
  - Include INSERT policy for RLS when using triggers that insert data
  - The `update_updated_at_column()` function is reusable for other tables
---

## 2026-01-23 - US-004
- What was implemented:
  - Created SQL migration file for user_settings table at `supabase/migrations/20260123000002_create_user_settings_table.sql`
  - Fields: id (uuid PK), user_id (uuid FK unique), reminder_enabled (bool default true), reminder_threshold_days (int default 90), expiration_reminder_days (int default 7), push_notifications_enabled (bool default false), default_view (varchar 20 default 'gallery'), created_at, updated_at
  - Enabled RLS on user_settings table
  - Added RLS policies: users can only read/update/insert their own settings
  - Added trigger `on_profile_created` to create user_settings when profile is inserted
  - Reused `update_updated_at_column` function from profiles migration for updated_at trigger
  - Added documentation comments on table and columns

- Files changed:
  - supabase/migrations/20260123000002_create_user_settings_table.sql (new)

- **Learnings for future iterations:**
  - The user_settings trigger listens to profiles table insert, not auth.users directly - this ensures proper chain: auth.users -> profiles -> user_settings
  - Reference user_id from NEW.user_id when trigger is on profiles table (not NEW.id)
  - The `update_updated_at_column()` function created in US-003 is shared across all tables
---

## 2026-01-23 - US-005
- What was implemented:
  - Created SQL migration file for categories table at `supabase/migrations/20260123000003_create_categories_table.sql`
  - Fields: id (uuid PK), user_id (uuid FK nullable), name (varchar 50), icon (varchar 10 default box emoji), color (varchar 7 default gray), is_system (bool default false), sort_order (int default 0), created_at
  - Enabled RLS on categories table
  - Added RLS policies: system categories readable by all authenticated users, user categories only by owner
  - Added separate policies for SELECT, INSERT, UPDATE, DELETE on user categories
  - Inserted 10 system preset categories: Clothing, Food & Beverage, Electronics, Kitchen, Sports & Fitness, Tools, Books & Documents, Personal Care, Home Decor, Other
  - Each system category has unique icon, color, and sort_order

- Files changed:
  - supabase/migrations/20260123000003_create_categories_table.sql (new)

- **Learnings for future iterations:**
  - System categories have user_id = NULL and is_system = true
  - User categories have user_id set and is_system = false
  - RLS policies need to check is_system flag to prevent users from modifying system categories
  - Categories table doesn't need updated_at since category changes are rare
---

## 2026-01-23 - US-006
- What was implemented:
  - Created SQL migration file for locations table at `supabase/migrations/20260123000004_create_locations_table.sql`
  - Fields: id (uuid PK), user_id (uuid FK), name (varchar 100), parent_id (uuid FK self-ref nullable), path (text), depth (int default 1), icon (varchar 10 default pin emoji), photo_url (text nullable), item_count (int default 0), created_at, updated_at, deleted_at (nullable)
  - Enabled RLS on locations table with user-only access policies
  - Added separate policies for SELECT, INSERT, UPDATE, DELETE operations
  - SELECT policy filters out soft-deleted locations (deleted_at IS NULL)
  - Added indexes on user_id, parent_id, and deleted_at columns
  - Reused `update_updated_at_column` function from profiles migration for updated_at trigger
  - Created `update_location_path` function and trigger to auto-maintain path and depth fields
  - Added comprehensive documentation comments on table and columns

- Files changed:
  - supabase/migrations/20260123000004_create_locations_table.sql (new)

- **Learnings for future iterations:**
  - Locations table uses self-referential FK (parent_id references locations.id) for hierarchy
  - ON DELETE SET NULL for parent_id allows graceful handling when parent location is deleted
  - The path field is auto-maintained by trigger using format "Parent > Child > Grandchild"
  - The depth field is auto-calculated (1 for root, increments per level)
  - item_count will be maintained by triggers on the items table (US-009)
  - Soft delete pattern: deleted_at is nullable, SELECT policy filters out non-null deleted_at
---

## 2026-01-23 - US-007
- What was implemented:
  - Created SQL migration file for items table at `supabase/migrations/20260123000005_create_items_table.sql`
  - Fields: id (uuid PK), user_id (uuid FK), photo_url (text NOT NULL), thumbnail_url (text nullable), name (varchar 200 nullable), description (text nullable), category_id (uuid FK nullable), tags (text[] default {}), location_id (uuid FK nullable), quantity (int default 1 with check 1-999), price (decimal 10,2 nullable), currency (varchar 3 default CNY), purchase_date (date nullable), expiration_date (date nullable), brand (varchar 100 nullable), model (varchar 100 nullable), notes (text nullable), is_favorite (bool default false), keep_forever (bool default false), ai_metadata (jsonb nullable), last_viewed_at (timestamptz nullable), created_at, updated_at, deleted_at (nullable)
  - Enabled RLS on items table with user-only access policies
  - Added separate policies for SELECT, INSERT, UPDATE, DELETE operations
  - SELECT policy filters out soft-deleted items (deleted_at IS NULL)
  - Added indexes on user_id, category_id, location_id, deleted_at columns
  - Reused `update_updated_at_column` function from profiles migration for updated_at trigger
  - Added comprehensive documentation comments on table and columns

- Files changed:
  - supabase/migrations/20260123000005_create_items_table.sql (new)

- **Learnings for future iterations:**
  - Items table uses ON DELETE SET NULL for category_id and location_id to allow graceful handling when category/location is deleted
  - The tags field uses PostgreSQL array type (text[]) with default empty array '{}'
  - Added CHECK constraint on quantity (1-999) for data validation
  - The ai_metadata field is JSONB for storing AI analysis results flexibly
  - keep_forever=true excludes items from unused item reminders
  - The location.item_count field will be maintained by triggers in US-009
---

## 2026-01-23 - US-008
- What was implemented:
  - Created SQL migration file for notifications table at `supabase/migrations/20260123000006_create_notifications_table.sql`
  - Fields: id (uuid PK), user_id (uuid FK), type (varchar 30 with CHECK constraint: unused_item, expiring_item, system), title (varchar 200 NOT NULL), body (text), item_id (uuid FK nullable), is_read (bool default false), is_pushed (bool default false), pushed_at (timestamptz nullable), created_at
  - Enabled RLS on notifications table with user-only access policies
  - Added separate policies for SELECT, INSERT, UPDATE, DELETE operations
  - Added indexes on user_id, is_read, and composite (user_id, is_read) for query performance
  - Used ON DELETE CASCADE for item_id FK (notifications deleted when item is deleted)
  - Added comprehensive documentation comments on table and columns

- Files changed:
  - supabase/migrations/20260123000006_create_notifications_table.sql (new)

- **Learnings for future iterations:**
  - Notifications table uses CHECK constraint for type enum rather than PostgreSQL ENUM type (simpler migrations)
  - ON DELETE CASCADE for item_id ensures notifications are cleaned up when items are deleted
  - Composite index on (user_id, is_read) optimizes common query pattern for unread notification counts
  - No updated_at column needed since notifications are typically write-once (only is_read changes)
---

## 2026-01-23 - US-009
- What was implemented:
  - Created SQL migration file for location item_count trigger at `supabase/migrations/20260123000007_create_location_item_count_trigger.sql`
  - Created `update_location_item_count()` function to handle all item count changes
  - Handles INSERT: increment new location's count if location_id is set and item is not soft-deleted
  - Handles DELETE (hard delete): decrement location's count if location_id was set
  - Handles UPDATE with soft-delete: decrement count when deleted_at changes from NULL to a value
  - Handles UPDATE with restore: increment count when deleted_at changes from a value to NULL
  - Handles UPDATE location_id change: decrement old location, increment new location
  - All operations use GREATEST(item_count - 1, 0) to prevent negative counts
  - Trigger fires AFTER INSERT OR UPDATE OR DELETE for each row

- Files changed:
  - supabase/migrations/20260123000007_create_location_item_count_trigger.sql (new)

- **Learnings for future iterations:**
  - Use AFTER trigger (not BEFORE) when updating related tables since it fires after the main operation completes
  - Use `IS DISTINCT FROM` for null-safe comparison of location_id changes
  - Use GREATEST(item_count - 1, 0) to prevent negative item counts (defensive programming)
  - Need to check both location_id and deleted_at status when calculating whether to update counts
  - The trigger handles restore from soft-delete (deleted_at NULL -> value -> NULL cycle)
---

## 2026-01-23 - US-010
- What was implemented:
  - Created SQL migration file at `supabase/migrations/20260123000008_add_pgvector_embedding.sql`
  - Enabled pgvector extension with `CREATE EXTENSION IF NOT EXISTS vector`
  - Added embedding column to items table: vector(1536) nullable for OpenAI text-embedding-3-small compatibility
  - Created HNSW index on embedding column using vector_cosine_ops for cosine similarity
  - Created `search_items_by_embedding()` function (SECURITY DEFINER) for server-side similarity search with explicit user_id parameter
  - Created `search_similar_items()` function (SECURITY INVOKER) for client-side use that respects RLS via auth.uid()
  - Both functions support configurable match_threshold and match_count parameters

- Files changed:
  - supabase/migrations/20260123000008_add_pgvector_embedding.sql (new)

- **Learnings for future iterations:**
  - pgvector extension is pre-installed in Supabase but needs to be explicitly enabled
  - HNSW (Hierarchical Navigable Small World) index is preferred over IVFFlat for better query performance without training
  - Use `<=>` operator for cosine distance in pgvector (returns distance, so similarity = 1 - distance)
  - SECURITY DEFINER functions bypass RLS - use explicit user_id parameter for server-side calls
  - SECURITY INVOKER functions respect RLS - use auth.uid() for client-side calls
  - HNSW parameters: m=16 (connections per layer), ef_construction=64 (construction quality) are good defaults
---

## 2026-01-23 - US-011
- What was implemented:
  - Updated /src/types/database.ts with comprehensive TypeScript interfaces matching database schema:
    - Profile: User profile extending auth.users
    - UserSettings: User personalization preferences with default_view union type
    - Category: Category with nullable user_id for system vs user categories
    - Location: Storage location with hierarchical support (parent_id, path, depth)
    - Item: Core inventory item with tags array, ai_metadata JSONB, and pgvector embedding
    - Notification: User notification with NotificationType union type
    - ItemAIMetadata: Flexible JSON interface for AI analysis results
  - Created Supabase Database type definition with Row, Insert, Update types for each table
  - Added Functions type definitions for search_similar_items and search_items_by_embedding
  - Added utility types: TableRow, TableInsert, TableUpdate for type extraction
  - Created /src/types/api.ts with comprehensive request/response types:
    - Generic API types (ApiResponse, ApiError, PaginatedResponse)
    - Auth request/response types
    - CRUD types for all entities (Create, Update, Response types)
    - AI analysis types (DetectedItem, AnalyzeImageResponse, ShoppingAnalyzeResponse)
    - Dashboard and search types
  - Created /src/types/index.ts as central export point for all types

- Files changed:
  - src/types/database.ts (updated with full schema types)
  - src/types/api.ts (new)
  - src/types/index.ts (new)

- **Learnings for future iterations:**
  - Use union types for constrained string fields like `default_view: 'gallery' | 'list'`
  - pgvector embedding is typed as `number[] | null` since TypeScript doesn't have a native vector type
  - ItemAIMetadata uses index signature `[key: string]: unknown` for flexible AI response storage
  - Supabase Database type uses Row/Insert/Update pattern for table type definitions
  - Insert types make auto-generated fields optional (id, created_at, etc.)
  - Update types use Partial and exclude fields that shouldn't be updated (id, user_id, etc.)
---

## 2026-01-23 - US-012
- What was implemented:
  - Created SQL migration file at `supabase/migrations/20260123000009_create_items_storage_bucket.sql`
  - Created 'items' storage bucket with INSERT INTO storage.buckets
  - Configured file_size_limit to 10MB (10485760 bytes)
  - Configured allowed_mime_types: image/jpeg, image/png, image/webp, image/heic
  - Created RLS policies for storage.objects table:
    - INSERT policy: Users can upload to items/{user_id}/* folder only
    - SELECT policy: Users can read/download their own files only
    - UPDATE policy: Users can update their own files only
    - DELETE policy: Users can delete their own files only
  - Used storage.foldername(name)[1] to extract user_id from file path for RLS checks

- Files changed:
  - supabase/migrations/20260123000009_create_items_storage_bucket.sql (new)

- **Learnings for future iterations:**
  - Supabase storage buckets are managed via storage.buckets table (INSERT/UPDATE)
  - Use ON CONFLICT DO UPDATE to make migration idempotent for bucket settings
  - RLS policies on storage.objects control file access, using storage.foldername() helper
  - storage.foldername(name) returns array of folder path segments, [1] gets first folder (user_id)
  - File path structure: bucket/{user_id}/{filename} - user_id is extracted for RLS
  - bucket_id field in storage.objects identifies which bucket the file belongs to
---

## 2026-01-23 - US-013
- What was implemented:
  - Created /src/contexts/AuthContext.tsx with AuthProvider component
  - Created /src/contexts/authContext.ts with AuthContext (separated for Fast Refresh compatibility)
  - Created /src/hooks/useAuth.ts hook to consume AuthContext
  - Created /src/types/auth.ts with AuthContextValue interface
  - AuthProvider provides: user, session, loading, signUp, signIn, signOut, resetPassword, updatePassword
  - Listens to supabase.auth.onAuthStateChange for session updates
  - Handles token expiry (SIGNED_OUT event) and token refresh (TOKEN_REFRESHED event)
  - Configured path aliases (`@/`) in vite.config.ts and tsconfig.app.json

- Files changed:
  - src/contexts/AuthContext.tsx (new - AuthProvider component)
  - src/contexts/authContext.ts (new - AuthContext instance)
  - src/hooks/useAuth.ts (new - useAuth hook)
  - src/types/auth.ts (new - AuthContextValue type)
  - src/types/index.ts (added AuthContextValue export)
  - src/lib/supabase.ts (updated to use @/ path alias)
  - vite.config.ts (added path alias configuration)
  - tsconfig.app.json (added path alias configuration)

- **Learnings for future iterations:**
  - React Fast Refresh plugin requires component-only exports in .tsx files
  - Separate context instance (createContext) from provider component for ESLint compliance
  - Use @/ path alias for cleaner imports (configured in both vite.config.ts and tsconfig.app.json)
  - supabase.auth.onAuthStateChange provides events: SIGNED_IN, SIGNED_OUT, TOKEN_REFRESHED, etc.
  - Always use useCallback for context methods to prevent unnecessary re-renders
  - useMemo for context value prevents child re-renders when state hasn't changed
---

## 2026-01-23 - US-014
- What was implemented:
  - Created /src/components/ProtectedRoute.tsx wrapper component
  - Check authentication status from AuthContext via useAuth hook
  - Redirects unauthenticated users to /login with redirect param preserving original path
  - Shows animated loading spinner while checking auth status
  - Renders children when user is authenticated
  - Uses encodeURIComponent for safe redirect URL encoding

- Files changed:
  - src/components/ProtectedRoute.tsx (new)

- **Learnings for future iterations:**
  - Use `useLocation()` from react-router-dom to get current pathname and search params
  - Preserve original path with `encodeURIComponent(location.pathname + location.search)` for post-login redirect
  - Use `<Navigate to={...} replace />` to redirect without adding to browser history
  - The loading state from useAuth is true until initial session check completes
  - Use `<>{children}</>` to render children without extra wrapper element
---

## 2026-01-23 - US-015
- What was implemented:
  - Created /src/components/layout/AppShell.tsx with header area and bottom nav integration
  - Created /src/components/layout/BottomNav.tsx with 4 tabs: Home, Add (center FAB), Inventory, Settings
  - Bottom nav is fixed at bottom, 56px height (h-14), white background with top border
  - Active tab highlighted with blue-600 primary color, icon filled and text bold
  - Center Add button is larger/prominent FAB style with blue-600 background
  - Tabs navigate to: /dashboard, /add, /inventory, /settings
  - Created layout index.ts for clean exports
  - Updated App.tsx to use AppShell and added placeholder pages for each route
  - Renamed context files to avoid macOS case-sensitivity issues (AuthContext.tsx -> AuthProvider.tsx, authContext.ts -> auth-context.ts)
  - Created /src/contexts/index.ts for clean context exports

- Files changed:
  - src/components/layout/AppShell.tsx (new)
  - src/components/layout/BottomNav.tsx (new)
  - src/components/layout/index.ts (new)
  - src/contexts/AuthProvider.tsx (renamed from AuthContext.tsx)
  - src/contexts/auth-context.ts (renamed from authContext.ts)
  - src/contexts/index.ts (new)
  - src/App.tsx (updated - added AppShell, placeholder pages, routes)
  - src/hooks/useAuth.ts (updated import path)

- **Learnings for future iterations:**
  - On macOS (case-insensitive file system), avoid files with same name different case (e.g., authContext.ts vs AuthContext.tsx)
  - Use dash-separated naming for consistency (auth-context.ts) when splitting context and provider
  - Create index.ts files for directories to provide clean exports
  - BottomNav uses NavLink from react-router-dom with active state detection via useLocation
  - FAB style center button uses negative margin (-mt-5) to extend above the nav bar
  - AppShell adds pb-14 (padding-bottom 56px) to content to account for fixed bottom nav
---

## 2026-01-23 - US-016
- What was implemented:
  - Created /src/pages/SignupPage.tsx at route /signup with full registration form
  - Email input with real-time validation (email format check using regex)
  - Password input with validation (minimum 8 characters)
  - Confirm password input with validation (must match password)
  - Inline validation errors shown below each field on blur
  - Create Account button disabled until all validations pass
  - Footer link: "Already have an account? Log in" -> /login
  - Created /src/pages/index.ts barrel export for pages
  - Updated App.tsx to add /signup route outside AppShell (no bottom nav for auth pages)

- Files changed:
  - src/pages/SignupPage.tsx (new)
  - src/pages/index.ts (new)
  - src/App.tsx (updated - restructured routes to separate auth from protected routes)

- **Learnings for future iterations:**
  - Auth pages (/signup, /login, etc.) should be outside AppShell since they don't need bottom navigation
  - Use nested Routes for grouping protected routes inside AppShell wrapper
  - Form validation pattern: use `touched` state to track which fields have been visited, only show errors for touched fields
  - Use `useMemo` for computing validation errors to avoid recalculating on every render
  - Email validation regex: `/^[^\s@]+@[^\s@]+\.[^\s@]+$/` covers most common cases
  - Button disabled state: combine isFormValid check with Tailwind conditional classes
---

## 2026-01-23 - US-017
- What was implemented:
  - Connected SignupPage form to AuthContext signUp function using useAuth hook
  - Added isSubmitting state to track form submission in progress
  - Button shows loading spinner (SVG animated) during submission with "Creating Account..." text
  - Form inputs are disabled during submission to prevent double-submit
  - On success: auto-login via Supabase, navigate to /dashboard with replace
  - On email exists error: show inline error "This email is already registered" with "Log in" link
  - On network error: show toast notification "Network connection failed"
  - On other errors: show toast notification "Registration failed. Please try again later"
  - Created /src/components/Toast.tsx - simple toast notification component (to be expanded in US-083)

- Files changed:
  - src/pages/SignupPage.tsx (updated - added form submission, loading state, error handling)
  - src/components/Toast.tsx (new - simple toast component)

- **Learnings for future iterations:**
  - Supabase error messages can be checked with .includes() for specific error types (e.g., 'user already registered')
  - Use try/catch to handle unexpected errors like network failures
  - Form inputs should be disabled during submission to prevent double-submit
  - Toast component positioned at bottom-20 to account for BottomNav (h-14 = 56px)
  - Loading spinner uses Tailwind animate-spin class with SVG circle and path
---

## 2026-01-23 - US-018
- What was implemented:
  - Created /src/pages/LoginPage.tsx at route /login with login form UI
  - Email input with real-time validation (email format check)
  - Password input with "Forgot password?" link to /reset-password
  - Log in button with loading state (spinner + "Logging in..." text during submission)
  - Form inputs disabled during submission to prevent double-submit
  - Footer link: "Don't have an account? Sign up" -> /signup
  - Updated /src/pages/index.ts to export LoginPage
  - Updated App.tsx to add /login route outside AppShell (no bottom nav for auth pages)

- Files changed:
  - src/pages/LoginPage.tsx (new)
  - src/pages/index.ts (updated - added LoginPage export)
  - src/App.tsx (updated - added /login route)

- **Learnings for future iterations:**
  - Login form is simpler than signup - only email and password fields (no confirm password)
  - "Forgot password?" link positioned inline with password label using flexbox justify-between
  - Form submission logic placeholder added (actual API call to be implemented in US-019)
  - Consistent UI patterns with SignupPage: same input styling, button states, layout structure
---

## 2026-01-23 - US-019
- What was implemented:
  - Connected LoginPage form to AuthContext signIn function via useAuth hook
  - Added redirect handling for successful login using useNavigate
  - On success: redirect to /dashboard or ?redirect= param if present (using decodeURIComponent)
  - On invalid credentials: show inline error "Invalid email or password" with red background box
  - On email not confirmed: show "Please verify your email address before logging in"
  - On network error: show toast notification "Network connection failed"
  - Added useEffect to redirect authenticated users visiting /login to /dashboard
  - Added loginError state for inline credential errors, toast state for network errors

- Files changed:
  - src/pages/LoginPage.tsx (updated - added signIn integration, error handling, redirect logic)

- **Learnings for future iterations:**
  - Supabase auth error message for invalid credentials is "Invalid login credentials" (case-insensitive check)
  - Use useSearchParams() from react-router-dom to read query params like ?redirect=
  - decodeURIComponent() should be used when reading redirect param since it was encoded during redirect
  - Separate inline error display (loginError state) from toast notifications (toast state) for better UX
  - The useEffect handles both initial load redirect and post-login redirect (when user state changes)
---

## 2026-01-23 - US-020
- What was implemented:
  - Created /src/pages/SettingsPage.tsx at route /settings
  - Added red Log out button fixed at bottom of settings page (above BottomNav)
  - Created inline confirmation dialog with "Log out?" heading and "Are you sure you want to log out?" text
  - Connected to AuthContext signOut function via useAuth hook
  - On confirm: calls signOut, shows "Logged out successfully" toast, redirects to /login
  - Shows loading state during logout with spinner animation
  - Dialog has backdrop that closes on click, and both Cancel and Log out buttons
  - Updated pages index.ts to export SettingsPage
  - Removed placeholder SettingsPage from App.tsx and imported from pages

- Files changed:
  - src/pages/SettingsPage.tsx (new)
  - src/pages/index.ts (updated - added SettingsPage export)
  - src/App.tsx (updated - removed placeholder, imported SettingsPage from pages)

- **Learnings for future iterations:**
  - Logout button positioned fixed at bottom-20 (above BottomNav h-14) with px-4 for padding
  - Confirmation dialogs use fixed inset-0 z-50 with backdrop (bg-black/50) and centered card
  - Use setTimeout before navigate to allow user to see success toast briefly
  - Dialog buttons should be disabled during async operation to prevent double-click
  - Use animate-in classes for dialog entry animations (zoom-in, fade-in)
---

## 2026-01-23 - US-021
- What was implemented:
  - Created /src/pages/ResetPasswordPage.tsx at route /reset-password
  - Form with email input and "Send Reset Email" button
  - Helper text explaining the password reset process
  - Email validation with real-time error display
  - On submit: calls AuthContext resetPassword (which calls supabase.auth.resetPasswordForEmail)
  - Always shows success view after submission (security: doesn't reveal if email exists)
  - Success view shows masked email (e.g., te***@example.com)
  - Resend button with 60-second cooldown timer that counts down
  - Tips section for users who don't receive the email
  - Network error handling with toast notification
  - Navigation links: "Remember your password? Log in" and "Back to Log in"
  - Updated pages index.ts to export ResetPasswordPage
  - Updated App.tsx to add /reset-password route outside AppShell

- Files changed:
  - src/pages/ResetPasswordPage.tsx (new)
  - src/pages/index.ts (updated - added ResetPasswordPage export)
  - src/App.tsx (updated - added /reset-password route)

- **Learnings for future iterations:**
  - Password reset should always show success message for security (don't reveal if email exists)
  - Use useEffect with setInterval for countdown timers, clean up with clearInterval
  - Mask email for display: show first 2 chars of local part + "***" + "@" + domain
  - The resetPassword function in AuthContext includes redirectTo parameter pointing to /reset-password/confirm
  - Cooldown pattern: track remaining seconds in state, disable button when > 0
---

## 2026-01-23 - US-022
- What was implemented:
  - Created /src/pages/ResetPasswordConfirmPage.tsx at route /reset-password/confirm
  - Form with new password and confirm password inputs
  - Password validation: minimum 8 characters, passwords must match
  - Token validation using Supabase auth session check via onAuthStateChange
  - Three states: loading (verifying token), invalid (expired/bad token), valid (show form)
  - On success: signs out user, redirects to /login with location state for success toast
  - On expired/invalid token: shows error view with "Request New Link" and "Back to Log in" buttons
  - Updated LoginPage to show "Password reset successfully" toast when redirected from password reset
  - Used useState initializer function to set initial toast state from location state (avoids lint error)
  - Updated pages index.ts to export ResetPasswordConfirmPage
  - Added route for /reset-password/confirm in App.tsx outside AppShell (no bottom nav)

- Files changed:
  - src/pages/ResetPasswordConfirmPage.tsx (new)
  - src/pages/LoginPage.tsx (updated - added success toast for password reset redirect)
  - src/pages/index.ts (updated - added ResetPasswordConfirmPage export)
  - src/App.tsx (updated - added /reset-password/confirm route)

- **Learnings for future iterations:**
  - Supabase handles password recovery tokens via URL hash automatically
  - Use onAuthStateChange to listen for PASSWORD_RECOVERY event when Supabase processes reset link
  - After updatePassword(), sign out the user and redirect to login for fresh session
  - Use location.state to pass data between routes (e.g., success message from password reset)
  - Use useState initializer function `useState(() => computeInitialValue())` to set initial state from props/context to avoid setState-in-effect lint error
  - Use window.history.replaceState({}, document.title) to clear location state without triggering navigation
---

## 2026-01-23 - US-023
- What was implemented:
  - Created /src/lib/imageUtils.ts with comprehensive image utility functions
  - Function validateImage: validates images for supported formats (JPEG, PNG, WebP, HEIC) and minimum dimensions (200x200)
  - Function compressImage: resizes and compresses images to max 2MB, adjusts quality iteratively
  - Function convertHeicToJpeg: converts HEIC/HEIF files to JPEG using heic2any library
  - Function generateThumbnail: creates 200x200 center-cropped square thumbnails
  - Function uploadToStorage: uploads to Supabase storage at items/{user_id}/{uuid}.jpg path, returns URL
  - Function processAndUploadImage: convenience function combining validate, compress, thumbnail, and upload
  - Added helper functions: getImageDimensions, loadImage, resizeImage, generateFilename, deleteFromStorage
  - Installed heic2any library for HEIC conversion
  - Created type declaration file for heic2any at /src/types/heic2any.d.ts

- Files changed:
  - package.json (added heic2any dependency)
  - package-lock.json (dependency lock file)
  - src/lib/imageUtils.ts (new - image utility functions)
  - src/types/heic2any.d.ts (new - TypeScript declaration for heic2any)

- **Learnings for future iterations:**
  - heic2any library doesn't have bundled TypeScript types, need to create custom .d.ts declaration
  - HEIC files may not have correct MIME type set, also check filename extension
  - Canvas-based image compression works by reducing dimensions and JPEG quality iteratively
  - Use crypto.randomUUID() for generating unique filenames (browser built-in)
  - Center-crop for thumbnails: calculate square crop from center of original image
  - heic2any returns Blob or Blob[] (for multi-frame images), handle array case
  - Use Promise-based wrappers for canvas.toBlob() and image loading for async/await compatibility
---

## 2026-01-23 - US-024
- What was implemented:
  - Created /src/pages/AddItemPage.tsx at route /add
  - Page title "Add Item" at the top
  - Two action cards: Take Photo (camera icon) and Choose from Gallery (image icon)
  - Helper text: "Take a photo of your item and AI will help identify it"
  - Take Photo triggers hidden input with capture="environment" for rear camera
  - Choose from Gallery triggers hidden file input accepting image/*
  - Camera permission handling with toast notification fallback
  - Image validation using existing validateImage utility from imageUtils
  - Processing indicator while validating images
  - Tips section for best photo results
  - Toast notifications for errors
  - Updated pages/index.ts to export AddItemPage
  - Removed placeholder AddItemPage from App.tsx

- Files changed:
  - src/pages/AddItemPage.tsx (new)
  - src/pages/index.ts (updated - added AddItemPage export)
  - src/App.tsx (updated - removed placeholder, imported from @/pages)

- **Learnings for future iterations:**
  - Use useRef for hidden file inputs and trigger with .click()
  - capture="environment" attribute requests rear camera on mobile devices
  - Reset input.value after file selection to allow selecting the same file again
  - Check navigator.mediaDevices existence before attempting camera access
  - The AddItemPage will navigate to preview step (US-025) after image validation
---

## 2026-01-23 - US-025
- What was implemented:
  - Added full-screen photo preview step to AddItemPage after image capture/selection
  - Implemented pinch-to-zoom support with touch events for mobile devices
  - Added double-tap gesture to toggle between 100% and 200% zoom
  - Zoom indicator shows current zoom percentage when zoomed in
  - Bottom action buttons: Retake/Reselect (left) and Continue (right, primary)
  - Button shows "Retake" when image was from camera, "Reselect" when from gallery
  - Retake/Reselect returns to capture options, cleaning up preview URL
  - Continue button ready for AI analysis integration (US-027)
  - Validates image before showing preview (uses existing validateImage utility)
  - Shows error toast for invalid images
  - Helper text shows "Pinch to zoom â€¢ Double-tap to reset" instructions
  - Clean URL.createObjectURL/revokeObjectURL lifecycle management

- Files changed:
  - src/pages/AddItemPage.tsx (updated - added preview view with pinch-to-zoom)

- **Learnings for future iterations:**
  - Use React.TouchEvent handlers for pinch-to-zoom: onTouchStart, onTouchMove, onTouchEnd
  - Calculate distance between two touch points with Math.hypot()
  - Use refs for mutable values that don't trigger re-renders (lastTouchDistanceRef, lastTapRef)
  - CSS `touch-none` class prevents default browser gestures on the preview container
  - Transform with translate inside scale needs to divide by scale for correct positioning
  - Clean up URL.createObjectURL with URL.revokeObjectURL to prevent memory leaks
  - Use useCallback for touch handlers to prevent unnecessary re-renders
  - Track isFromCamera state to show appropriate button label (Retake vs Reselect)
---

## 2026-01-23 - US-026
- What was implemented:
  - Created Supabase Edge Function: analyze-image at `supabase/functions/analyze-image/index.ts`
  - Created shared CORS headers at `supabase/functions/_shared/cors.ts`
  - Accepts image URL in request body via POST
  - Calls OpenAI GPT-4o Vision API with detailed prompt for item detection
  - Extracts: item name(s), category suggestion (from predefined system categories), tags, brand (if visible), confidence score
  - Returns JSON with detected_items array, analysis_model, and analyzed_at timestamp
  - Handles API errors gracefully with appropriate error codes (CONFIGURATION_ERROR, UNAUTHORIZED, INVALID_REQUEST, INTERNAL_ERROR)
  - Secures function with auth token validation using Supabase auth.getUser()
  - Validates image_url format and required fields
  - Uses lower temperature (0.3) for consistent results

- Files changed:
  - supabase/functions/analyze-image/index.ts (new - Edge Function)
  - supabase/functions/_shared/cors.ts (new - shared CORS headers)

- **Learnings for future iterations:**
  - Supabase Edge Functions use Deno runtime with esm.sh imports
  - Use `Deno.serve()` for the main handler (new Deno 2.0 pattern)
  - Import Supabase client from 'https://esm.sh/@supabase/supabase-js@2'
  - CORS headers should handle OPTIONS preflight requests first
  - OpenAI Vision API accepts image URLs directly in the message content
  - GPT-4o can handle JSON-only responses with proper prompting
  - Handle potential markdown code blocks in OpenAI responses when parsing JSON
  - Use `Deno.env.get()` to access environment variables (OPENAI_API_KEY, SUPABASE_URL, SUPABASE_ANON_KEY)
  - Validate auth by creating Supabase client with user's token and calling auth.getUser()
  - Category suggestions should match existing system categories for consistency
---

## 2026-01-23 - US-027
- What was implemented:
  - Updated AddItemPage.tsx with AI analysis loading and results UI
  - Added new view states: 'analyzing', 'results', 'error'
  - Created full-screen loading overlay with spinner and dynamic text
  - Implemented 5-second text change ('Still analyzing, please wait...')
  - Implemented 15-second timeout with Cancel and Keep Waiting buttons
  - Added image upload to storage before calling analyze-image Edge Function
  - On success with single item: navigates to /add/edit with pre-filled data
  - On success with multiple items: shows selection UI (placeholder for US-028)
  - On failure: shows error UI with "Add Manually" and "Try a Different Photo" options
  - Added proper cleanup for uploaded images when analysis is cancelled
  - Added abort controller for cancelling in-flight requests

- Files changed:
  - src/pages/AddItemPage.tsx (updated - added AI analysis flow)

- **Learnings for future iterations:**
  - Use AbortController for cancellable async operations (fetch, Edge Function calls)
  - Can't use hooks inside render functions - extract state to component level
  - Use refs (analysisTimersRef) to track setTimeout IDs for cleanup
  - Call supabase.functions.invoke() with Authorization header for authenticated Edge Functions
  - Navigate with state object to pass data between routes (detectedItem, imageUrl, etc.)
  - processAndUploadImage() returns imagePath and thumbnailPath for cleanup if needed
  - Use useCallback for derived values that depend on state (getAnalysisLoadingText)
---

## 2026-01-23 - US-028
- What was implemented:
  - Created /src/components/MultiItemSelection.tsx component for multi-item selection
  - Displays original photo at top of selection UI
  - Lists detected items with: checkbox, name, category suggestion, confidence badge (High/Medium/Low)
  - AI sparkle indicator shows which fields are AI-detected
  - Tags preview (first 3 tags with "+N more" overflow indicator)
  - Brand information display when available
  - Select All / Deselect All toggle functionality
  - Add Selected Items button with dynamic count (disabled when none selected)
  - Helper text "You'll edit each item one by one" when multiple items selected
  - Item queue navigation: passes selected items to Item Editor with queue state
  - Updated AddItemPage.tsx to use MultiItemSelection component instead of placeholder
  - Consistent state structure for all navigation paths (single item, multi-item, manual add)
  - Added itemQueue, totalItems, currentItemIndex to navigation state for US-035

- Files changed:
  - src/components/MultiItemSelection.tsx (new)
  - src/pages/AddItemPage.tsx (updated - integrated MultiItemSelection component)

- **Learnings for future iterations:**
  - Use Set for tracking selected indices for O(1) lookup and efficient toggling
  - Confidence thresholds: >=0.8 High (green), >=0.6 Medium (yellow), <0.6 Low (gray)
  - Navigation state should include queue info (itemQueue, totalItems, currentItemIndex) for multi-item flows
  - ImageInfo type contains all image-related data (imageUrl, thumbnailUrl, imagePath, thumbnailPath)
  - Safe-area-pb class handles iPhone notch/safe-area padding for bottom action bar
  - Buttons should be interactive (use <button> not <div>) for full accessibility with tab/enter
---

## 2026-01-23 - US-029
- What was implemented:
  - Created /src/components/ItemEditor.tsx component with basic form fields
  - Photo thumbnail at top with tap-to-view functionality (opens full image modal)
  - Name input with placeholder 'e.g., Blue Coffee Mug', max 200 chars, character counter
  - Quantity stepper component with increment/decrement buttons (min 1, max 999)
  - Description textarea with placeholder 'Add notes...', max 1000 chars, character counter
  - AI sparkle indicator badge for AI pre-filled fields (shows "AI" pill with sparkle icon)
  - Sparkle/AI indicator disappears when user modifies the field
  - Progress indicator for multi-item queue (shows "Adding item X of Y" with dot progress)
  - Full image viewer modal with tap-anywhere-to-close
  - Created /src/pages/ItemEditorPage.tsx wrapper for routing with state handling
  - Redirects to /add when accessed directly without state (security)
  - Updated App.tsx to add route for /add/edit
  - Fixed NodeJS.Timeout type to use ReturnType<typeof setTimeout> for browser compatibility

- Files changed:
  - src/components/ItemEditor.tsx (new)
  - src/pages/ItemEditorPage.tsx (new)
  - src/pages/index.ts (added ItemEditorPage export)
  - src/App.tsx (added /add/edit route, imported ItemEditorPage)
  - src/pages/AddItemPage.tsx (fixed NodeJS.Timeout type)

- **Learnings for future iterations:**
  - Use `ReturnType<typeof setTimeout>` instead of `NodeJS.Timeout` for browser TypeScript compatibility
  - Don't re-export types that are already exported in the same file (causes TS2484)
  - ItemEditorPage uses location.state from React Router for passing data (detectedItem, imageUrl, etc.)
  - ItemEditor component receives form data and notifies parent via onFormChange callback
  - AIFilledFields state tracks which fields have AI sparkle indicator
  - QuantityStepper is a separate component with increment/decrement buttons and input field
  - Use [appearance:textfield] and [&::-webkit-*]:appearance-none to hide number input spinners
  - Full image viewer uses z-50 fixed positioning with tap-anywhere-to-close pattern
---

## 2026-01-23 - US-030
- What was implemented:
  - Created /src/hooks/useCategories.ts hook for fetching and managing categories
  - Hook provides: categories (system + user), isLoading, error, createCategory, getSortedCategories
  - Categories sorted: AI suggestion first (with sparkle), then user categories, then system categories
  - Added CategorySelector component to ItemEditor with dropdown UI
  - Dropdown shows category icon, name, AI sparkle indicator for suggested category
  - Added 'Create new category' option at bottom of dropdown
  - Inline create form with name input, save button, cancel button
  - Validates category name: required, max 50 chars, no duplicate names
  - Auto-selects newly created category after creation
  - AI-suggested category auto-selected when categories load
  - Sparkle/AI indicator cleared when user manually selects a different category
  - Updated ItemEditorValues to include categoryId field
  - Added Relationships property to Database types for Supabase compatibility

- Files changed:
  - src/hooks/useCategories.ts (new)
  - src/components/ItemEditor.tsx (updated - added CategorySelector, categoryId state)
  - src/types/database.ts (updated - added Relationships to all table definitions)
  - scripts/ralph/prd.json (marked US-030 as passes: true)

- **Learnings for future iterations:**
  - useCategories hook at `/src/hooks/useCategories.ts` - use `const { categories, createCategory, getSortedCategories } = useCategories()`
  - For Supabase Database types, add `Relationships: []` to each table definition for compatibility
  - When using supabase.from().insert(), may need type assertion if Database types aren't fully inferred
  - React Compiler strict mode: avoid useState in useEffect, use derived state or callback patterns instead
  - Use stable references (extract to variables) for useMemo dependencies when accessing nested properties
  - CategorySelector uses click-outside detection with document.addEventListener('mousedown', ...)
  - For async category ID lookup, use derived state pattern: track `hasUserSelectedCategory` to distinguish manual vs auto selection
---
